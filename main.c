#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <linux/if_packet.h>
#include <net/ethernet.h>
#include <sys/ioctl.h>
#include <net/if.h>
//#include <net/if_arp.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

//global variables
int sockfd = -1;
#define max_MTU 1500
char buffer[max_MTU];

//function declarations
void initialize_firewall(const char *interface);
void sigint_handler();
void packet_garbage();
void packet_parsing(const char *buffer, ssize_t bytes_received);
void shutdown_firewall();

//initial point for the firewall program
int main(int argc, char *argv[]){

    //usage
    if(argc < 2){
        fprintf(stderr, "Usage: %s <network_interface>\n", argv[0]);
        return EXIT_FAILURE;
    }
    const char *interface = argv[1];
    printf("Starting firewall on interface: %s\n", interface);

    //initialize the firewall with the specified network interface
    initialize_firewall(interface);

    //set the signal handler to stop the firewall in secure way
    if(signal(SIGINT, sigint_handler) == SIG_ERR){
        perror("Error setting signal handler");
        shutdown_firewall(-1);
    }

    //main loop to keep the firewall running
    printf("Firewall is running. Press Ctrl+C to stop.\n");
    packet_garbage();

    //exit point
    shutdown_firewall(0);

}

/*
create and open a connection in promiscuous mode with the raw socket
*/
void initialize_firewall(const char *interface){

    /*
    raw socket creation:
        - AF_PACKET: allows raw access to the link layer;
        - SOCK_RAW: indicates that we want the packages in raw format, even with headers;
        - htons(ETH_P_ALL): indicates that we want to capture all Ethernet protocols.
    This will allow us to capture all packets on the specified interface.
    Note: This requires root privileges to run.
    */
    sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if(sockfd < 0){
        perror("Error creating raw socket");
        shutdown_firewall(-1);
    }

    /*
    raw socket to the promiscuous mode:
        - we use ioctl to set the interface to promiscuous mode, which allows the socket to capture all packets on the network, not just those addressed to it;
        - to use this command we need the file descriptor of the socket, the flag which indicates what we wanna do, and the struct that defines it;
        - SIOCSIFFLAGS: used to set the flags of the interface (the second S is to indicate SET, if we wanted to get the flags we would use G of GET);
        - struct ifreq: used to specify the interface and the flags we want to set (see man netdevice for the complete definition of the struct);
            - ifr_name: field inside the struct, represents the name of the interface we want to set
                (we need memset to zero and then copy the interface name into it cause it's an array);
            - IFF_PROMISC: flag inside the struct that indicates we want to set the interface to promiscuous mode.
    Note: there may be some error calls generated by VSC that are fake positives, there are not any really errors in the code. Just compile and you will see.
            The reason is (probably) that VSC cannot find the definition of the struct ifreq with its checker, while the compiler can;
            infact, the tip of the VSC's compiler is that misses the library, while it's included.
    */
    struct ifreq flags_settings;
    memset(&flags_settings, 0, sizeof(flags_settings)); //zero the struct
    strncpy(flags_settings.ifr_name, interface, IFNAMSIZ - 1);
    flags_settings.ifr_name[IFNAMSIZ - 1] = '\0';
    // |= is a equal OR operator, so it sets the flag but without removing the others (all the flag are in a bitmask
    //so the flag depends on the position of the bit (like 00001000) is only promiscuous mode, but we need the others default flags too);
    flags_settings.ifr_flags |= IFF_PROMISC;
    if(ioctl(sockfd, SIOCSIFFLAGS, &flags_settings) == -1){
        perror("Error setting interface to promiscuous mode");
        shutdown_firewall(-1);
    }

    /*
    TODO:
    add binding between the socket and the desired interface (without the default it is loopback).
    */

    printf("Firewall initialized on interface: %s\n", interface);
    return;
}


/*
this function is called when the user presses Ctrl+C (SIGINT).
It will shutdown the firewall in secure way and close the raw socket.
*/
void sigint_handler(){
    /*
    TODO:
    maybe we can add a complete mask of signals to handle or ignore, to avoid the firewall to be stopped by an attacker from inside the system
    */
    printf("\n\n\n");
    shutdown_firewall(0);
}

void packet_garbage(){

    /*
    TODO:
    This function is a placeholder for the main loop of the firewall.
    It should contain the logic to process incoming packets and apply firewall rules.
    For now, it just takes and prints the packets without any filtering or processing.
    */
    while(1){
        ssize_t bytes_received = recvfrom(sockfd, buffer, sizeof(buffer), 0, NULL, NULL);
        if(bytes_received < 0){
            perror("Error receiving packet");
            //delete the packet without comunicating it to the sender (reset the buffer)
            /*
            TODO:
            implement a logic to comunicate the sender that the packet has been dropped (depending on the reason why it has been dropped)
            */
            memset(buffer, 0, sizeof(buffer));
            continue;
        }
        printf("[FIREWALL] Received packet of size: %zd\n", bytes_received);
        /*printf("[FIREWALL] Packet content: ");
        for(ssize_t i = 0; i < bytes_received; i++){
            printf("%02x ", (unsigned char)buffer[i]);
        }
        printf("\n");*/
        packet_parsing(buffer, bytes_received);
    }
}

/*

*/
void packet_parsing(const char *buffer, ssize_t bytes_received){

    //dst MAC address parsing
    printf("\t[PACKET PARSING] Destination MAC address: ");
    for(ssize_t i = 0; i < 6; i++)
        printf("%02x ", (unsigned char)buffer[i]);
    printf("\n");
    //src MAC address parsing
    printf("\t[PACKET PARSING] Source MAC address: ");
    for(ssize_t i = 6; i < 12; i++)
        printf("%02x ", (unsigned char)buffer[i]);
    printf("\n");
    //Ethernet type parsing
    printf("\t[PACKET PARSING] Ethernet type: ");
    for(ssize_t i = 12; i < 14; i++)
        printf("%02x ", (unsigned char)buffer[i]);
    printf("\n");
    //IP header parsing (if present)
    if(bytes_received >= 14 && (buffer[12] == 0x08 && buffer[13] == 0x00)){ //check if it's an IP packet (Ethernet type 0x0800)
        printf("\t[PACKET PARSING] IP header:\n");
        //IP version and header length
        printf("\t\tVersion: %d\n", (buffer[14] >> 4) & 0x0F);
        printf("\t\tHeader length: %d bytes\n", (buffer[14] & 0x0F) * 4);
        //Type of Service
        printf("\t\tType of Service: %d\n", buffer[15]);
        //Total Length
        printf("\t\tTotal Length: %d bytes\n", (buffer[16] << 8) | buffer[17]);
        //Identification
        printf("\t\tIdentification: %d\n", (buffer[18] << 8) | buffer[19]);
        //Flags and Fragment Offset
        printf("\t\tFlags: %d\n", (buffer[20] >> 5) & 0x07);
        printf("\t\tFragment Offset: %d\n", ((buffer[20] & 0x1F) << 8) | buffer[21]);
        //Time to Live
        printf("\t\tTime to Live: %d\n", buffer[22]);
        //Protocol
        printf("\t\tProtocol: %d\n", buffer[23]);
        //Header Checksum
        printf("\t\tHeader Checksum: %04x\n", (buffer[24] << 8) | buffer[25]);
        //Source IP Address
        printf("\t\tSource IP Address: %d.%d.%d.%d\n",
               (unsigned char)buffer[26], (unsigned char)buffer[27],
               (unsigned char)buffer[28], (unsigned char)buffer[29]);
        //Destination IP Address
        printf("\t\tDestination IP Address: %d.%d.%d.%d\n",
               (unsigned char)buffer[30], (unsigned char)buffer[31],
               (unsigned char)buffer[32], (unsigned char)buffer[33]);
    } else {
        printf("\t[PACKET PARSING] Not an IP packet (Ethernet type 0x0800 not found).\n");
    }
}

/*
shutdown the firewall and close the raw socket
*/
void shutdown_firewall(int exit_flag){

    /*TODO*/
    //close the raw socket and cleanup
    close(sockfd);

    printf("Firewall stopped correctly.\n");
    exit(exit_flag);   
}