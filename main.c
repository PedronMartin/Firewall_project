#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <linux/if_packet.h>
#include <net/ethernet.h>
#include <sys/ioctl.h>
#include <net/if.h>
//#include <net/if_arp.h>
#include <string.h>
#include <unistd.h>

//global variables
int sockfd = -1;

//function declarations
void initialize_firewall(const char *interface);
void shutdown_firewall();

//initial point for the firewall program
int main(int argc, char *argv[]){

    //usage
    if(argc < 2){
        fprintf(stderr, "Usage: %s <network_interface>\n", argv[0]);
        return EXIT_FAILURE;
    }
    const char *interface = argv[1];
    printf("Starting firewall on interface: %s\n", interface);

    //initialize the firewall with the specified network interface
    initialize_firewall(interface);

    //exit point
    shutdown_firewall(0);

}

/*
create and open a connection in promiscuous mode with the raw socket
*/
void initialize_firewall(const char *interface){

    /*
    raw socket creation:
        - AF_PACKET: allows raw access to the link layer;
        - SOCK_RAW: indicates that we want the packages in raw format, even with headers;
        - htons(ETH_P_ALL): indicates that we want to capture all Ethernet protocols.
    This will allow us to capture all packets on the specified interface.
    Note: This requires root privileges to run.
    */
    sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if(sockfd < 0){
        perror("Error creating raw socket");
        shutdown_firewall(-1);
    }

    /*
    raw socket to the promiscuous mode:
        - we use ioctl to set the interface to promiscuous mode, which allows the socket to capture all packets on the network, not just those addressed to it;
        - to use this command we need the file descriptor of the socket, the flag which indicates what we wanna do, and the struct that defines it;
        - SIOCSIFFLAGS: used to set the flags of the interface (the second S is to indicate SET, if we wanted to get the flags we would use G of GET);
        - struct ifreq: used to specify the interface and the flags we want to set (see man netdevice for the complete definition of the struct);
            - ifr_name: field inside the struct, represents the name of the interface we want to set
                (we need memset to zero and then copy the interface name into it cause it's an array);
            - IFF_PROMISC: flag inside the struct that indicates we want to set the interface to promiscuous mode.
    Note: there may be some error calls generated by VSC that are fake positives, there are not any really errors in the code. Just compile and you will see.
            The reason is (probably) that VSC cannot find the definition of the struct ifreq with its checker, while the compiler can;
            infact, the tip of the VSC's compiler is that misses the library, while it's included.
    */
    struct ifreq flags_settings;
    memset(&flags_settings, 0, sizeof(flags_settings)); //zero the struct
    strncpy(flags_settings.ifr_name, interface, IFNAMSIZ - 1);
    flags_settings.ifr_name[IFNAMSIZ - 1] = '\0';
    // |= is a equal OR operator, so it sets the flag but without removing the others (all the flag are in a bitmask
    //so the flag depends on the position of the bit (like 00001000) is only promiscuous mode, but we need the others default flags too);
    flags_settings.ifr_flags |= IFF_PROMISC;
    if(ioctl(sockfd, SIOCSIFFLAGS, &flags_settings) == -1){
        perror("Error setting interface to promiscuous mode");
        shutdown_firewall(-1);
    }

    printf("Firewall initialized on interface: %s\n", interface);
    return;
}

/*
shutdown the firewall and close the raw socket
*/
void shutdown_firewall(int exit_flag){

    /*TODO*/
    //close the raw socket and cleanup
    close(sockfd);

    printf("Firewall stopped correctly.\n");
    exit(exit_flag);   
}